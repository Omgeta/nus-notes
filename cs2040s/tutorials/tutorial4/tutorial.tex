\documentclass[12pt, a4paper]{article}

\usepackage[a4paper, margin=1in]{geometry}

\input{preamble}
\input{letterfonts}

\newcommand{\mytitle}{CS2040S Tutorial 4}
\newcommand{\myauthor}{github/omgeta}
\newcommand{\mydate}{AY 24/25 Sem 2}

\begin{document}
\raggedright
\footnotesize
\begin{center}
{\normalsize{\textbf{\mytitle}}} \\
{\footnotesize{\mydate\hspace{2pt}\textemdash\hspace{2pt}\myauthor}}
\end{center}
\setlist{topsep=-1em, itemsep=-1em, parsep=2em}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                      Begin                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{enumerate}[Q\arabic*.]
  \item 
    \begin{enumerate}[(\alph*.)]
      \item 
        \begin{enumproof}
        \item Find the successor of node $70$ 
        \item Since the right subtree is available, search there
        \item Successor found is node $72$, swap values and delete the node
        \end{enumproof}

      \item No; we rotate right on node $72$ which is left-heavy.

      \item $39, 52, 57, 58, 65, 68, 70, 72$

      \item Use the 2 bits to store balance factor. We can use 2 bits excess-1 to store values $-1, 0, 1$ for balanced AVL trees. If an operation were to make the tree imbalanced, we just balance it and set the new balance factor instead.

      \item 
        \begin{enumproof}
        \item Take first element to be the root and partition around it
        \item All elements less than the root form the new left subtree
        \item All elements more than the root from the new right subtree
        \item Recursively apply the steps 1-3 to the left and right subtrees
        \end{enumproof}
    \end{enumerate}

  \item Pseudocode:
    \begin{lstlisting}
Node[] inOrder(Node root) {
    Node[] res = new Node[];
    Stack s = new Stack();
    Node curr = root;

    while (curr || !s.isEmpty()) {
      // scan left-wise
      while (curr != null) {
        s.push(curr);
        curr = curr.left;
      }
      
      // curr is null now
      curr = s.pop();
      res.push(curr);

      // add right node now
      curr = curr.right;
    }
    
    return res;
}
    \end{lstlisting}

  \item 
    \begin{enumerate}[(\alph*.)]
      \item Bites left on winning: $1$

      \item Bites left on winning: $O(\log n), $Total bites: $O(n)$, 
        \begin{enumproof}
        \item Tournament-style, compare every 2 and continue with winners
        \end{enumproof}

      \item Bites left on median: $O(\log n), $Total bites: $O(n)$, 
        \begin{enumproof}
        \item QuickSelect-style, choosing pivot plates at random and recursing on the side with less than $\frac{n}{2}$ elements
        \end{enumproof}
    \end{enumerate}

  \pagebreak
  \item 

  \item 
    \begin{enumproof}
    \item Calculate the height and depth of each node using in-order traversal and DFS respectively, each $O(n)$
    \item Store the results in an array of Pairs, grouping by depth
    \item When a node is removed with depth $d$, find the node with the maximum height $h_d$ with the same depth $d$
    \item Our final height will just be $d + h_d$
    \end{enumproof}
\end{enumerate}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                       End                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

\documentclass[12pt, a4paper]{article}

\usepackage[a4paper, margin=1in]{geometry}

\input{preamble}
\input{letterfonts}

\newcommand{\mytitle}{CS2100 Tutorial 1}
\newcommand{\myauthor}{github/omgeta}
\newcommand{\mydate}{AY 24/25 Sem 2}

\begin{document}
\raggedright
\footnotesize
\begin{center}
{\normalsize{\textbf{\mytitle}}} \\
{\footnotesize{\mydate\hspace{2pt}\textemdash\hspace{2pt}\myauthor}}
\end{center}
\setlist{topsep=-1em, itemsep=-1em, parsep=2em}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                      Begin                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{enumerate}[Q\arabic*.]
  \item 
    \begin{enumproof}
    \item Suppose $x = msb(x) << (n-1) + r$ is the $n$-bit number to be extended to $m$-bit number $y$
    \item Case 1 ($msb(x) = 0$): left padding by zero has no effect so $y=x$
    \item Case 2 ($msb(x) = 1$):
      \begin{enumproof}
      \item $y = 1_1\cdots 1_{m-n+1} << (n-1) + r$, i.e. sign extension adds $m-n$ leading ones
      \item $y = -2^{m-1} + 2^{m-2} + \cdots + 2^{n-1} + r$
      \item $y = -2^{m-1} + 2^{n-1}(2^{m-n}-1) + r$\hfill(Geometric progression)
      \item $y = -2^{m-1} + 2^{m-1} - 2^{n-1} + r = -2^{n-1} + r$
      \item $\therefore y = 1 << (n-1) + r = x$
      \end{enumproof}
    \item Therefore, in both cases sign extension is value preserving $\qed$
    \end{enumproof}

  \item Sign extension is used to add left padded zeros for component binaries
    \begin{enumerate}[\alph*.]
      \item $0101.1100 - 0010.0101 = 0101.1100 + 1101.1010 = 0011.0111_{1s} \qed$
      \item $010111.101 - 0111010.11 = 0010111.101 + 1000101.001 = 1011100.110_{1s} \qed$
    \end{enumerate}

  \item 
    \begin{enumerate}[\alph*.]
      \item $1.75 \xrightarrow{\text{to binary}}0001.110_{2s} \qed$
      \item $-2.5 \xrightarrow{\text{to binary}}1101.100_{2s} \qed$
      \item $3.876 \xrightarrow{\text{to binary}}0011.111_{2s} \qed$
      \item $2.1 \xrightarrow{\text{to binary}}0010.001_{2s} \qed$
    \end{enumerate}
    All numbers cannot be represented exactly and most must be approximated. Precision is limited by the number of fractional bits.

  \item $-0.078125 = -0.000101_2 = -1.01 \times 2^{-4}$\\
    Exponent = $-4 + 127 = 123 = 01111011_2$\\
    Representation $= 1$ $01111011$ $010000\cdots = 1011$ $1101$ $1010$ $0000\cdots =$ BDA00000 $\qed$

  \item \hfill\\ 
    \begin{lstlisting}
    int readArray(int arr[], int limit) {
      int i, input;

      printf("Enter up to %d integers, terminating with 
      a negative integer.\n", limit);

      for (i = 0; i < limit; i++) {
        scanf("%d", &input);
        if (input >= 0) arr[i] = input;
        else break;
      }

      return i;
    }
    \end{lstlisting}

  \pagebreak
  \item \hfill\\ 
    \begin{lstlisting}
    // Iterative
    void reverseArray(int arr[], int size) {
      for (int i = 0, j = size-1; i < j; i++, j--) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }
    }

    // Recursive
    void reverseArray(int arr[], int size) {
      if (size >= 2) {
        int tmp = arr[0];
        arr[0] = arr[size-1];
        arr[size-1] = tmp;
        reverseArray(arr+1, size-2);
      }
    }
    \end{lstlisting}

  \item a = 55, c = 15, e = 0\\
*b = 55, *d = 55, *f = 0 $\qed$

\end{enumerate}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                       End                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
